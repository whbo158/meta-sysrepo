diff --git a/src/session_server.c b/src/session_server.c
index 636b1a2..bf7f180 100644
--- a/src/session_server.c
+++ b/src/session_server.c
@@ -163,6 +163,85 @@ nc_session_set_status(struct nc_session *session, NC_STATUS status)
     session->status = status;
 }
 
+#define SOCKET_FAILED (-1)
+
+#define HTONS(x) (htons(x))
+#define HTONL(x) (htonl(x))
+
+#define hy_warn printf
+#define TCP_BUF_LEN (1024)
+
+static char sdata_buf[TCP_BUF_LEN];
+
+static int si_flag = 0;
+static int tcp_start_listen_libnetconf(int port)
+{
+	struct sockaddr_in server_addr;
+	struct sockaddr_in client_addr;
+	char *pbuf = sdata_buf;
+	socklen_t addr_len;
+	int client_fd = 0;
+	int slisten_fd;
+	int opt = 1;
+	int ret = 0;
+
+	if (si_flag) {
+		printf("%s: has been runned!\n", __func__);
+		return 0;
+	}
+
+	si_flag = 1;
+
+	bzero(&server_addr, sizeof(server_addr));
+	server_addr.sin_family = AF_INET;
+	server_addr.sin_port = HTONS(port);
+	server_addr.sin_addr.s_addr = HTONL(INADDR_ANY);
+
+	slisten_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	if (slisten_fd == SOCKET_FAILED) {
+		hy_warn("%s: create socket failed. info:%s\n", __func__, strerror(errno));
+		goto ret_tag;
+	}
+
+	setsockopt(slisten_fd, SOL_SOCKET, SO_REUSEADDR, (const void *)&opt, sizeof(opt));
+
+	ret = bind(slisten_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));
+	if (ret == SOCKET_FAILED) {
+		hy_warn("%s: bind socket failed. info:%s\n", __func__, strerror(errno));
+		goto ret_tag;
+	}
+	hy_warn("%s: bind port:%d OK! info:%s\n", __func__, strerror(errno));
+
+	ret = listen(slisten_fd, 5);
+	if (ret == SOCKET_FAILED) {
+		hy_warn("%s: listen socket failed. info:%s\n", __func__, strerror(errno));
+		goto ret_tag;
+	}
+
+	client_fd = accept(slisten_fd, (struct sockaddr *)&client_addr, &addr_len);
+	if (client_fd == SOCKET_FAILED) {
+		hy_warn("%s: accept failed. info:%s\n", __func__, strerror(errno));
+		goto ret_tag;
+	}
+
+	while (0) {
+		ret = recv(client_fd, pbuf, TCP_BUF_LEN, 0);
+		if (ret < 0)
+			break;
+
+		printf("recv:%s\n", pbuf);
+	}
+
+	return 0;
+
+ret_tag:
+	if (slisten_fd != SOCKET_FAILED)
+		close(slisten_fd);
+
+	return ret;
+}
+
+
 int
 nc_sock_listen_inet(const char *address, uint16_t port)
 {
@@ -173,6 +252,7 @@ nc_sock_listen_inet(const char *address, uint16_t port)
     struct sockaddr_in *saddr4;
     struct sockaddr_in6 *saddr6;
 
+    //tcp_start_listen_libnetconf(830);
 
     if (!strchr(address, ':')) {
         is_ipv4 = 1;
@@ -188,11 +268,11 @@ nc_sock_listen_inet(const char *address, uint16_t port)
 
     /* these options will be inherited by accepted sockets */
     opt = 1;
-    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof opt) == -1) {
+    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {
         ERR("Could not set SO_REUSEADDR socket option (%s).", strerror(errno));
         goto fail;
     }
-    if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1) {
+    if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt)) == -1) {
         ERR("Could not set TCP_NODELAY socket option (%s).", strerror(errno));
         goto fail;
     }
@@ -214,10 +294,11 @@ nc_sock_listen_inet(const char *address, uint16_t port)
         }
 
         if (bind(sock, (struct sockaddr *)saddr4, sizeof(struct sockaddr_in)) == -1) {
-            ERR("Could not bind \"%s\" port %d (%s).", address, port, strerror(errno));
+            ERR("%s: Could not bind \"%s\" port %d (%s).", __func__, address, port, strerror(errno));
             goto fail;
         }
 
+	VRB("%s: bind addr:%s port:%d OK\n", __func__, address, port);
     } else {
         saddr6 = (struct sockaddr_in6 *)&saddr;
 
