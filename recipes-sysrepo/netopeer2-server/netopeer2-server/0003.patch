diff --git a/CMakeLists.txt b/CMakeLists.txt
index 882e591..ed5b09e 100755
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -180,20 +180,20 @@ if (ENABLE_CONFIGURATION)
     configure_file("${CMAKE_CURRENT_SOURCE_DIR}/scripts/model-install.sh.in" "${PROJECT_BINARY_DIR}/model-install.sh" ESCAPE_QUOTES @ONLY)
 
     # find sysrepoctl
-    if (NOT SYSREPOCTL_EXECUTABLE)
-        find_program(SYSREPOCTL_EXECUTABLE sysrepoctl)
-    endif()
-    if (NOT SYSREPOCTL_EXECUTABLE)
-        message(FATAL_ERROR "Unable to find sysrepoctl, set SYSREPOCTL_EXECUTABLE manually.")
-    endif()
+    # if (NOT SYSREPOCTL_EXECUTABLE)
+    #   find_program(SYSREPOCTL_EXECUTABLE sysrepoctl)
+    #endif()
+    #if (NOT SYSREPOCTL_EXECUTABLE)
+    #   message(FATAL_ERROR "Unable to find sysrepoctl, set SYSREPOCTL_EXECUTABLE manually.")
+    #endif()
 
     # find sysrepocfg
-    if (NOT SYSREPOCFG_EXECUTABLE)
-        find_program(SYSREPOCFG_EXECUTABLE sysrepocfg)
-    endif()
-    if (NOT SYSREPOCFG_EXECUTABLE)
-        message(FATAL_ERROR "Unable to find sysrepocfg, set SYSREPOCFG_EXECUTABLE manually.")
-    endif()
+    #if (NOT SYSREPOCFG_EXECUTABLE)
+    #    find_program(SYSREPOCFG_EXECUTABLE sysrepocfg)
+    #endif()
+    #if (NOT SYSREPOCFG_EXECUTABLE)
+    #    message(FATAL_ERROR "Unable to find sysrepocfg, set SYSREPOCFG_EXECUTABLE manually.")
+    #endif()
 
     # Command line options to be passed to `sysrepoctl` when working with modules
     # which should only be accessible by an administrator
@@ -226,18 +226,4 @@ if(ENABLE_VALGRIND_TESTS)
     set(ENABLE_BUILD_TESTS ON)
 endif()
 
-if(ENABLE_BUILD_TESTS)
-    find_package(CMocka 1.0.0)
-    if(CMOCKA_FOUND)
-        enable_testing()
-        add_subdirectory(tests)
-    endif(CMOCKA_FOUND)
-endif(ENABLE_BUILD_TESTS)
-
-add_custom_target(integration-test
-                  COMMAND make build
-                  COMMAND make test
-                  WORKING_DIRECTORY integration-tests/
-                  COMMENT Running integration-tests)
-
 file(COPY integration-tests DESTINATION ${CMAKE_BINARY_DIR})
diff --git a/ietf_netconf_server.c b/ietf_netconf_server.c
index 37dc0c6..348a296 100644
--- a/ietf_netconf_server.c
+++ b/ietf_netconf_server.c
@@ -122,6 +122,7 @@ set_listen_endpoint_port(const char *endpt_name, sr_change_oper_t sr_oper, sr_va
     switch (sr_oper) {
     case SR_OP_CREATED:
     case SR_OP_MODIFIED:
+	//sr_new_val->data.uint16_val = 1023;
         rc = nc_server_endpt_set_port(endpt_name, sr_new_val->data.uint16_val);
         break;
     case SR_OP_DELETED:
@@ -768,6 +769,7 @@ module_change_resolve(sr_session_ctx_t *srs, sr_change_oper_t sr_oper, sr_val_t
                     rc = set_listen_endpoint_address(list1_key, sr_oper, sr_old_val, sr_new_val);
                 } else if (!strcmp(xpath, "port")) {
                     rc = set_listen_endpoint_port(list1_key, sr_oper, sr_old_val, sr_new_val);
+                    VRB("%s: bind port\n", __func__);
                 } else if (!strcmp(xpath, "host-keys")) {
                     /* ignore */
                     rc = 0;
diff --git a/main.c b/main.c
index 601e8a8..01460e4 100644
--- a/main.c
+++ b/main.c
@@ -1527,6 +1527,81 @@ static gid_t parse_gid(const char *arg)
     return grp->gr_gid;
 }
 
+#define SOCKET_FAILED (-1)
+#define HTONS(x) (htons(x))
+#define HTONL(x) (htonl(x))
+#define hy_warn printf
+#define TCP_BUF_LEN (1024)
+
+static char sdata_buf[TCP_BUF_LEN];
+
+static int si_flag = 0;
+static int tcp_start_listen(int port)
+{
+	struct sockaddr_in server_addr;
+	struct sockaddr_in client_addr;
+	char *pbuf = sdata_buf;
+	socklen_t addr_len;
+	int client_fd = 0;
+	int slisten_fd;
+	int opt = 1;
+	int ret = 0;
+
+	if (si_flag) {
+		printf("%s: has been runned!\n", __func__);
+		return 0;
+	}
+	si_flag = 1;
+
+	bzero(&server_addr, sizeof(server_addr));
+	server_addr.sin_family = AF_INET;
+	server_addr.sin_port = HTONS(port);
+	server_addr.sin_addr.s_addr = HTONL(INADDR_ANY);
+
+	slisten_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	if (slisten_fd == SOCKET_FAILED) {
+		hy_warn("%s: create socket failed. info:%s\n", __func__, strerror(errno));
+		goto ret_tag;
+	}
+
+	setsockopt(slisten_fd, SOL_SOCKET, SO_REUSEADDR, (const void *)&opt, sizeof(opt));
+
+	ret = bind(slisten_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));
+	if (ret == SOCKET_FAILED) {
+		hy_warn("%s: bind port:%d failed. info:%s\n", __func__, port, strerror(errno));
+		goto ret_tag;
+	}
+	hy_warn("%s: bind port:%d OK! info:%s\n", __func__, port, strerror(errno));
+
+	ret = listen(slisten_fd, 5);
+	if (ret == SOCKET_FAILED) {
+		hy_warn("%s: listen socket failed. info:%s\n", __func__, strerror(errno));
+		goto ret_tag;
+	}
+
+	client_fd = accept(slisten_fd, (struct sockaddr *)&client_addr, &addr_len);
+	if (client_fd == SOCKET_FAILED) {
+		hy_warn("%s: accept failed. info:%s\n", __func__, strerror(errno));
+		goto ret_tag;
+	}
+
+	while (1) {
+		ret = recv(client_fd, pbuf, TCP_BUF_LEN, 0);
+		if (ret < 0)
+			break;
+
+		printf("recv:%s\n", pbuf);
+	}
+
+	return 0;
+
+ret_tag:
+	if (slisten_fd != SOCKET_FAILED)
+		close(slisten_fd);
+
+	return ret;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -1541,6 +1616,11 @@ main(int argc, char *argv[])
     struct sigaction action;
     sigset_t block_mask;
 
+#if 0
+    tcp_start_listen(830);
+    return 0;
+#endif
+
     /* until daemonized, write messages to both syslog and stderr */
     openlog("netopeer2-server", LOG_PID, LOG_DAEMON);
     np2_stderr_log = 1;
